The most computationally expensive aspect of nbody_seq is the update function.
When converting this serial program to a parallel one with pthreads, I focused
on making the update function a parallel computation and left the other parts of
the program as sequential, since they involved I/O operations. During the
initialization of the program, I divide up the Body array using a simple block
distribution and assign each block to one of the threads. I chose a block
distribution because it is a fast and simple way to divide the Bodies array
among the threads. Inside the main loop of the simulation, I spawn the defined
amount of threads and have them launch into the update function, where they each
iterate through the Bodies they own and update their properties. I then join the
threads when they are done and go to the next simulation nstep.

In terms of performance, the pthread version performed better than the
sequential version for larger values of num_threads and Bodies. With 40 threads,
the speedup was: (72.489391 / 9.574215) = 7.5713. However, having more than 15
threads showed a trend of diminished returns, since adding more threads did not
significantly increase the speedup after this point.
